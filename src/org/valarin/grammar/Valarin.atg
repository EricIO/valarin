COMPILER Valarin

CHARACTERS
	Digit              = '0' .. '9'.
	Zero               = '0'.
	NonZero            = '1' .. '9'.
	HexDigit           = Digit + 'a' .. 'f'.
	BinaryDigit        = "01".
	OctalDigit         = '0' .. '7'.
	Letter             = 'A' .. 'z'.
	IdentStart         = Letter + '-' + '_'.
	IdentifierChar     = IdentStart + Digit.
	Escape             = "\\".
	DoubleQuote        = "\"".
	Quote              = "\'".
	AnyButDoubleQuote  = ANY - DoubleQuote.
	AnyButQuote        = ANY - Quote .
	Cr                 = '\r'.
	Lf                 = '\n'.
	Tab                = '\t'.
	ListOpen           = '['.
	ListClose          = ']'.
	Eol                = Lf.

TOKENS
	ident  = IdentStart {IdentifierChar}.
	// TODO: Add octal,hex and binary digit notation.
	// TODO: Should we have just one number type or ints and floats?
	number = Zero
			 | (NonZero {Digit}).
	float  = (Zero | (NonZero | {Digit})) "." Digit {Digit}.
    // Let "string" and 'string' be valid string literals.
	string = "\"" { ( AnyButDoubleQuote | Escape DoubleQuote | Escape Escape) } "\""
			 | "\'" { AnyButQuote | Escape Quote | Escape Escape} "\'".
	eol    = Eol.

COMMENTS FROM "%" TO '\n'
IGNORE '\t' + '\n' + '\r'

PRODUCTIONS
	Valarin = 	 										(. ArrayList<ValExpressionNode> nodes = new ArrayList<>(); .)
			  {
				(
					Expr<out ValExpressionNode result>  (. nodes.add(result); .)
				)
			  }											(. root = new ValBodyNode(nodes.toArray(new ValStatementNode[nodes.size()])); .)
			  .
	Expr <out ValExpressionNode expr> =
		(Arithmetic <out expr> | LogicExpression<out expr>) ";".

	Arithmetic<out ValExpressionNode expr> =
		Term<out expr> 
		{ 
			("+" | "-")									(. Token op = t; .)
			Term<out ValExpressionNode e2>	 			(. expr = factory.createBinaryNode(op, expr, e2); .)
		}.
		
	Term<out ValExpressionNode expr> =
		Factor<out expr>
		{ 
			("*" | "/") 								(. Token op = t; .)
			Factor<out ValExpressionNode e2>			(. expr = factory.createBinaryNode(op, expr, e2); .)
		}.
		
	Factor<out ValExpressionNode expr> =
		Power<out expr>
		{
			"**"										(. Token op = t; .)
			Power<out ValExpressionNode e2>				(. expr = factory.createBinaryNode(op, expr, e2); .)
		}.
	
	Power<out ValExpressionNode result> = 				(. result = null; .)
		(
			number										(. result = factory.createNumberLiteral(t); .)
			| "(" Expr<out result> ")"
			| string									(. result = factory.createStringLiteral(t); .)
		).
		
	LogicExpression<out ValExpressionNode expr> =
		Boolean<out expr>
		{
			("||" | "&&")								(. Token op = t; .)
			Boolean<out ex2>							(. expr = factory.createBinaryNode(op, expr, ex2); .)
		}.
	
	Boolean<out ValExpressionNode result> = 
	{
		("true" | "false")								(. result = factory.createBooleanLiteral(t); .)
		| "(" Expr<out result> ")"
	}.
END Valarin.
